---
title: django踩坑
date: 2019/9/7 7:22:22
tags: React
categories: 
- Py后端
---

> 时间: 2019/7/09：

没错我想开了，菜鸟上的django教程坑太多了，它写的很简练，但是坑多。

关于数据库模型查询数据的结果集这一块，菜鸟上写的是用一个for in来遍历结果集object中的数据，然后返回，所以我一开始也是这么做的：

<!--more-->
```python
# 获取全部数据集
def listDataSets(request):
    result = []
    allData = DataSet.objects.all().order_by('-id')
    for obj in allData:
        item = {}
        item['key'] = obj.id
        item['id'] = obj.id
        item['name'] = obj.name
        item['description'] = obj.description
        item['size'] = obj.size
        item['createdBy'] = obj.createdBy
        item['createdAt'] = obj.createdAt.strftime( '%y-%m-%d %I:%M:%S %p' )  
        item['status'] = obj.status
        item['path'] = obj.path
        item['clazzNum'] = obj.clazzNum
        result.append(item)
    print(result)
    return HttpResponse(json.dumps(result))
```

我发现这样太傻了，万一有几十个字段怕不是要被搞到死哟~

直接返回这个结果集肯定是会被报错的，然后今天早上我发现了一个神奇的包：
```python
from django.core import serializers

from django.core import serializers
# 获取数据集信息
def getDataSet(request):
    result = DataSet.objects.filter(id=request.GET.get("id"))
    return HttpResponse(serializers.serialize('json',result))
```

然后竟然成功了，呵呵。。。万幸万幸。。。

***后续***：
前两天我又发现DJango本身还有另外一个专门应对这个场合的包：
```python
from django.forms.models import model_to_dict

result = {} 
for service in ServiceSet.objects.all():
    # 获取数据
    item = model_to_dict(service)
    result[service.id] = item
```


<hr>

因为志浩的深度学习系统是用python写的，为了免去跨语言的麻烦，我也要用python封装web接口，所以选择了django框架写接口。从此踏上了踩坑之旅。

> 坑一

在菜鸟上的表单POST提交方法写的好好的接口，换了axios之后后台接不到参数，不管是request.POST("id")还是request.POST.get("id")都不行
神奇的发现必须采用content-type : urlencoded才能接收到，在axios传递的参数上用qs.parse(data)转一下就立马可以了。

> 坑二

官方反csrf标记token导致无法请求接口。
官方有说明，只要在setting中注释掉这一行就好了：
```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

> 坑三

建的好好的数据库模型，从服务器上下载到本地，只要一运行迁移命令，就会报错：
```python
>>> python manage.py migrate
The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "manage.py", line 21, in <module>
    main()

#.....省略一大堆路径信息.....
django.db.utils.OperationalError: (1067, "Invalid default value for 'status'")
```

我发现，只要这个dbmodel文件夹是由命令：
```
django-admin startapp TestModel
```
生成的才可以，不然就会各种字段默认值不符合之类的错误。

其实也还可以这样改：在model文件夹目录下的
```
model/migrations/000X_auto_timestamp.py
```
里面把字段的defaultvalue改了就好了：
```
# Generated by Django 2.2.2 on 2019-07-08 01:44

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    dependencies = [
        ('DbModel', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='dataset',
            name='clazzName',
            field=models.TextField(default=""),
            preserve_default=False,
        ),

```